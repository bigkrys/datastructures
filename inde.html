<!DOCTYPE html>
<html>
    <body></body>
    <script>
    class VEX{
        //邻接表中的散列表顶点
        constructor(value){
            this.data = value;
            this.link = null;//紧接着的邻接表
        }
    }
    class Link{
        //散列表中的链表顶点
        constructor(node,weight,value){
            this.node = node;//指向的是哪个顶点
            this.weight = weight;//权重
            this.next = null;
            this.value = value;
        }
    }
    class GraphTable{
        //无向图的邻接表 表示
        constructor(nodes,links){
            let table = new Array(nodes.length);
            for(let i = 0;i<nodes.length;i++){
                //初始化散列表
                table[i] = new VEX(nodes[i])
            }
            for(let link of links){
                let v1 = nodes.indexOf(link[0]);
                let v2 = nodes.indexOf(link[1]);


                let linknode2 = new Link(v2,link[2],link[1]);
                linknode2.next = table[v1].link;
                table[v1].link = linknode2;

                let linknode = new Link(v1,link[2],link[0]);
                linknode.next = table[v2].link;
                table[v2].link = linknode;
            }
            this.table = table;
            this.nodes = nodes
        }
    }




    class Graph{
    //无向图的邻接矩阵表示
    constructor(nodes,links){
        this.nodes =  nodes;//所有顶点数组,links是边之间的关系。
        let  matrix = [];
        for(let i = 0;i<nodes.length;i++){
            matrix[i] = new Array(nodes.length);//每一层都有一个数组，数组长度为顶点的个数
            for(let j = 0;j<nodes.length;j++){
                matrix[i][j] = i==j?0:null;//初始化邻接矩阵
            }
        }
        for(let link of links){
            //读取边的关系
            let v1 = nodes.indexOf(link[0]);//读取第一个边所在的下标
            let v2 = nodes.indexOf(link[1]);//读取第二个边所在的下标
            matrix[v1][v2] = matrix[v2][v1] = link[2] || 1;
        }
        this.matrix = matrix;
    }
   
}
    function GraphDFS(graph){
    //邻接矩阵的深度优先搜素
    //传入一个图 node是顶点集合 matrix是矩阵
    let visited = new Array(graph.nodes.length).fill(false);//用来存储 未被访问过的顶点
    for(let i = 0;i<graph.nodes.length;i++){
        //第一重遍历 是用来给他回溯用的
        if(!visited[i]){
            visited[i] = true;
            DFS(i);//从当前顶点开始深度遍历
        }
    }
    function DFS(i){
        console.log(graph.nodes[i]);//使用这个顶点
        for(let j = 0;j<graph.nodes.length;j++){
            if(graph.matrix[i][j] == 1 && !visited[j]){
                //如果当前两个顶点之间有边，且第二个顶点未被访问过（因为不要重复访问i的邻接顶点）
                visited[j] = true;
                DFS(j);//再从j开始往下深度遍历。
            }
        }
        //当走到没有头的时候退出循环了，等于回溯到原始i的位置，接着i++就是从下一个邻接点开始深度遍历

    }
    
}
function GraphTableDFS(graph){
    //邻接表的深度优先搜索
    let visited = new Array(graph.table.length).fill(false);//用来存储 未被访问过的顶点
    for(let i = 0;i<graph.table.length;i++){
        //第一重遍历 是用来给他回溯用的
        if(!visited[i]){
            visited[i] = true;
            DFS(i);//从当前顶点开始深度遍历
        }
    }
    function DFS(i){
        console.log(graph.table[i].data);//使用这个顶点
        //获取这个顶点的邻接表
        let link = graph.table[i].link;
        while(link){
            if(!visited[link.node]){
                visited[link.node] = true;
                DFS(link.node);
            }
            link = link.next;
        }
        //当走到没有头的时候退出循环了，等于回溯到原始i的位置，接着i++就是从下一个邻接点开始深度遍历

    }
}
function GraphBFS(graph){
    //邻接矩阵的广度优先搜索
    let quene = [];
    let visited = new Array(graph.nodes.length).fill(false);
    for(let i = 0;i<graph.nodes.length;i++){
        if(!visited[i]){
            visited[i] = true;
            quene.push(i);
            while(quene.length>0){
                let current  = quene.shift();
                console.log(graph.nodes[current]);
                for(let j = 0;j<graph.nodes.length;j++){
                    if(graph.matrix[i][j] == 1 && !visited[j]){
                        visited[j] = true;
                        quene.push(j);
                    }
                }

            }
        }
    }

}
function GraphTableBFS(graph){
    let quene = [];//用队列保存当前层的数据哦 每次遍历一当前邻接表，当当前邻接表访问结束，则访问下一个邻接表
    let visited = new Array(graph.table.length).fill(false);
    for(let i = 0;i<graph.table.length;i++){
        if(!visited[i]){
            visited[i] = true;
            quene.push(i);//将当前点入队
            while(quene.length>0){
                let current  = quene.shift();
                console.log(graph.table[current].data);
                let link = graph.table[current].link;
                while(link){
                    if(!visited[link.node]){
                        visited[link.node] = true;
                        quene.push(link.node);
                    }
                    link = link.next;
                }

            }
        }
    }
}
let nodes = ['A','B','C','D','E','F','G','H','I'];
let r = [['A','B',1],['A','F',1],['B','G',1],['F','G',1],['B','C',1],['B','I',1],['G','H',1],['C','I',1],['I','D',1],['H','D',1],['F','E',1],['H','E',1],['C','D',1]]
let g1 = new Graph(nodes,r)
let g2 = new GraphTable(nodes,r)
console.log(g1);
console.log(g2);

console.log('------------------------||||邻接矩阵的深度搜索')
GraphDFS(g1)
console.log('------------------------|||||邻接表的深度搜搜')
GraphTableDFS(g2)
console.log('------------------------|||||邻接矩阵的广度搜索')
GraphBFS(g1)
console.log('------------------------|||||邻接表的广度搜索')
GraphTableBFS(g2)
    </script>
</html>
