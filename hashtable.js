/**
 * 哈希表（散列表）
 * 
 * 散列的思想，就是用key对应着一个value。将key转换为value的方法叫做散列函数，而散列函数得到的value就是散列值，
 * 散列值也叫做哈希值。这个value就对应着数组的下表，然后根据value去数组中对应的位置存取数据。
 * 
 * 散列函数，hash(key)，其中key表示着元素的键值，has(key)-》value就是经过散列函数计算得到的散列值（哈希值）。
 * 
 * 散列函数设计的基本要求
 *  a.散列函数计算得到的散列值是一个非负整数
 *  b.如果key1 = key2 ,has(key1) = has(key2)
 *  c.如果key1 != key2,has(key1) != has(key2)
 * 
 * 
 * 散列冲突：就是两个不同的key 得到了一样的哈希值，就是散列冲突。
 * 
 * 常用的解决散列冲突的方法
 * 
 * （一） 开放寻址法：如果出现了散列冲突，重新探测一个空闲位置，将其插入。
 * 
 * 那么如何来探测是否有空闲位置，先来说一个
 * 
 * （1）.线性探测的方法：当我们往散列表中插入数据的时候，如果发生了散列冲突，就从当前位置开始，依次往后面查找，查看是否有空闲位置，直到找到为止。
 * 
 * 
 * 
 * 就是当你从散列函数中得到一个哈希值，然后根据这个哈希值去找到数组的下标，发现已经存放数据了，那么就从这个位置开始，按顺序地往后一个一个点着，看还有没有空位置，如果到了数组尾部，
 * 还是没有空闲位置，那么就从数组开头再往后查找，直到查找到了一个位置，于是插入元素。
 * 
 * 
 * 查找的过程也是这样，先通过散列函数求出哈希值，然后对比这个哈希值下标对应位置点数据是否和查找的元素一致，如果相等就找到了，如果不等，就按顺序往后依次查找。
 * 如果找到了一个空闲位置还是没有找到这个元素，证明查找元素不在散列表中。
 * 
 * 散列表删除一个元素的时候，不是直接把这个数据从散列表中提出掉，而是将其标志为deleted，当查找一个元素的时候，遇到deleted的元素块点时候，直接往下走，而不是
 * 认定为空。
 * 
 * 
 * 
 * (2).二次探测的方法：
 * 二次探测和线形探测的区别就是，
 * 线形探测每次往下走的时候是一步，而二次探测原来的二次方，比如当你遇到了散列冲突，需要往下查找位置插入元素的时候，第一次是hash(key)+0 ，第二次就是hash(key) + 1*1,
 * 第三次就是hash(key) + 2*2 ...以此类推
 * 
 * (3).双重散列：不仅使用一个散列函数，使用一组散列函数hash1(key),hash2(key),hash3(key)...，先用第一个hash1(key),如果此时发生散列冲突了，
 * 就使用第二个散列函数hash2(key),以此类推，直到找到空闲的存储位置。
 * 
 * 
 * 
 * 
 * 当空闲位置变小点时候，散列冲突的概率就会不断的变大，一般情况下，需要保证散列表中有一定比例的空闲槽位。空闲位置的多少，就是装载因子。
 * 装载因子越大，空闲位置越小，散列冲突的概率就会变大。
 * 
 * 装载因子的计算方式是：装载因子 = 填入元素中的个数/散列表的长度
 * 
 * 
 * 
 * （二）、链表法解决散列冲突
 * 链表法是更常用的解决散列冲突的方法，在散列表中存放的是一个链表的表头，当哈希值一样的数据，存放在这个链表中。
 * 
 * 比如 hash(5) = 5,hash(15) = 5,hash(20) = 5
 * 5\15\20都指向了5的下标位置，那么数组中，下标为5的位置存放的是一个链表的表头，链表是5->15-20。
 * 
 * 
 * 当插入元素的时候，只要通过散列函数得到哈希值，就将其插入对应的链表中。当查找的时候也是这样，先由散列函数得到一个哈希值，然后遍历对应的链表，查看是否有该值。
 * 删除元素的时候，通过散列函数得到哈希值，在对应的链表中删除这个元素。
 * 
 * 
 * 
 * 
 * 如何设计一个好的散列表？
 * 
 * （一）设计散列函数
 * 散列函数生成的值，要尽可能的随机并且均匀分布。
 * 
 * 
 * 
 * 
 */